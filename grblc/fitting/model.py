import inspect
from typing import Callable
from typing import List

import numpy as np


def chisq(x, y, sigma, model, p, return_reduced=False):
    """
    Calculate chisq for a given proposed solution

    chisq = Sum_i (Y_i - model(X_i, F, T, alpha, t))^2 / sigma_i^2,

    """

    x = np.asarray(x)
    y = np.asarray(y)
    sigma = np.asarray(sigma)
    r = y - model(x, *p)
    _chisq = np.sum(r ** 2 / sigma ** 2)

    if return_reduced:
        return _chisq, _chisq / (len(x) - len(p))
    else:
        return _chisq


# The famous Willingale et. al 2007 model
# modified so T and F are logarithmic inputs
# to avoid numerical overflow issues
def _w07(x, T, F, alpha, t):

    before = lambda x: (
        -t * 10 ** (-x) + alpha - alpha * 10 ** (x - T) + F * np.log(10)
    ) / np.log(10)

    after = lambda x: F + T * alpha - x * alpha - t * 10 ** (-x) / np.log(10)

    vals = np.piecewise(x, [x < T, x >= T], [before, after])
    return vals


def _simple_bpl(x, T, F, alpha1, alpha2):

    linT, linF = np.power(10, [T, F])
    linX = np.power(10, x)

    before = lambda x: linF * (x / linT) ** (-alpha1)
    after = lambda x: linF * (x / linT) ** (-alpha2)
    vals = np.piecewise(linX, [linX < linT, linX >= linT], [before, after])

    return np.log10(vals)


def _smooth_bpl(x, T, F, alpha1, alpha2, S):

    linT, linF = np.power(10, [T, F])
    linX = np.power(10, x)
    return np.log10(
        linF
        * ((linX / linT) ** (S * alpha1) + (linX / linT) ** (S * alpha2)) ** (-1 / S)
    )


class Parameter:
    def __init__(
        self, name, description=None, min=None, max=None, vary=True, plot_fmt=None
    ):
        self.name = name
        self.description = (
            description
            if description is not None
            else "Autogenerated argument from input function."
        )
        self.plot_fmt = plot_fmt if plot_fmt is not None else name
        self.min = min if min is not None else -np.inf
        self.max = max if min is not None else np.inf
        self.vary = vary


class Model:
    def __init__(
        self,
        func: Callable,
        name: str = "",
        slug: str = "",
        func_args: List[Parameter] = None,
        bounds: list = None,
    ):
        self.__func = func

        self.name = name if name else func.__name__
        self.slug = slug if slug else self.name
        func_argspec = np.asarray(inspect.getfullargspec(func).args[1:], dtype=str)
        if func_args is not None:
            # make sure that each value of in func_args is in func_argspec
            for p in func_args:
                if p.name not in func_argspec:
                    raise ValueError(
                        f"{p.name} is not a valid argument for the {self.name} model. Expected one of {func_argspec}."
                    )

            self.func_args = {p.name: p for p in func_args}

        else:
            # we assume 1 independent variable, and give blanket bounds to each param
            self.func_args = {
                name: Parameter(name) for name in inspect.getargspec(func).args[1:]
            }

        # xy bounds
        if bounds is not None:
            assert len(bounds) == 4, "bounds must be a list of length 4"
            self.bounds = bounds
        else:
            self.bounds = [-np.inf, np.inf, -np.inf, np.inf]  # blanket bounds

    def __call__(self, x: np.ndarray, *p, **kwargs):
        return self.func(x, *p[: len(self)], **kwargs)

    def __getitem__(self, key):
        return self.func_args[key]

    def __iter__(self):
        return iter(self.func_args)

    def __len__(self):
        return len(self.func_args)

    def __repr__(self) -> str:
        return f"<grbLC> Model({self.name})"

    @property
    def func(self) -> Callable:
        return self.__func

    @classmethod
    def W07(cls, vary_t=True):
        return cls(
            name="Willingale 2007",
            slug="w07",
            func=_w07,
            func_args=[
                Parameter(
                    "T",
                    "log time at end of plateau (log sec)",
                    min=0,
                    max=10,
                ),
                Parameter(
                    "F",
                    "log flux at end of plateau (log erg/cm^2/s)",
                    min=-20,
                    max=2,
                ),
                Parameter(
                    "alpha",
                    "temporal decay index of power law",
                    plot_fmt=r"$\alpha$",
                    min=0,
                    max=1.5,
                ),
                Parameter(
                    "t",
                    "log time at peak (log sec)",
                    min=0,
                    max=np.inf,
                    vary=vary_t,
                ),
            ],
        )

    @classmethod
    def SMOOTH_BPL(cls):
        return cls(
            name="smooth broken power law",
            slug="smooth_bpl",
            func=_smooth_bpl,
            func_args=[
                Parameter(
                    "T",
                    "log time at end of plateau (log sec)",
                    min=1e-5,
                    max=10,
                ),
                Parameter(
                    "F",
                    "log flux at end of plateau  (log erg cm^-2 s^-1)",
                    min=-20,
                    max=-2,
                ),
                Parameter(
                    "alpha1",
                    "temporal decay index of initial power law",
                    min=-5,
                    max=5,
                    plot_fmt=r"$\alpha_1$",
                ),
                Parameter(
                    "alpha2",
                    "temporal decay index of end power law",
                    min=0,
                    max=20,
                    plot_fmt=r"$\alpha_2$",
                ),
                Parameter("S", "smoothing factor"),
            ],
        )

    @classmethod
    def SIMPLE_BPL(cls):
        return cls(
            name="simple broken power law",
            slug="simple_bpl",
            func=_simple_bpl,
            func_args=[
                Parameter(
                    "T",
                    "log time at end of plateau (log sec)",
                    min=1e-5,
                    max=10,
                ),
                Parameter(
                    "F",
                    "log flux at end of plateau  (log erg cm^-2 s^-1)",
                    min=-20,
                    max=-2,
                ),
                Parameter(
                    "alpha1",
                    "temporal decay index of initial power law",
                    min=-5,
                    max=5,
                    plot_fmt=r"$\alpha_1$",
                ),
                Parameter(
                    "alpha2",
                    "temporal decay index of end power law",
                    min=0,
                    max=20,
                    plot_fmt=r"$\alpha_2$",
                ),
            ],
        )
